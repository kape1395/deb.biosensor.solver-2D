// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ModelSolver.hxx"

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        // FiniteDifferences
        // 

        const FiniteDifferences::axis_sequence& FiniteDifferences::
        axis () const
        {
          return this->axis_;
        }

        FiniteDifferences::axis_sequence& FiniteDifferences::
        axis ()
        {
          return this->axis_;
        }

        void FiniteDifferences::
        axis (const axis_sequence& s)
        {
          this->axis_ = s;
        }

        const FiniteDifferences::stopCondition_sequence& FiniteDifferences::
        stopCondition () const
        {
          return this->stopCondition_;
        }

        FiniteDifferences::stopCondition_sequence& FiniteDifferences::
        stopCondition ()
        {
          return this->stopCondition_;
        }

        void FiniteDifferences::
        stopCondition (const stopCondition_sequence& s)
        {
          this->stopCondition_ = s;
        }

        const FiniteDifferences::timeStepAdjuster_optional& FiniteDifferences::
        timeStepAdjuster () const
        {
          return this->timeStepAdjuster_;
        }

        FiniteDifferences::timeStepAdjuster_optional& FiniteDifferences::
        timeStepAdjuster ()
        {
          return this->timeStepAdjuster_;
        }

        void FiniteDifferences::
        timeStepAdjuster (const timeStepAdjuster_type& x)
        {
          this->timeStepAdjuster_.set (x);
        }

        void FiniteDifferences::
        timeStepAdjuster (const timeStepAdjuster_optional& x)
        {
          this->timeStepAdjuster_ = x;
        }

        void FiniteDifferences::
        timeStepAdjuster (::std::auto_ptr< timeStepAdjuster_type > x)
        {
          this->timeStepAdjuster_.set (x);
        }

        const FiniteDifferences::timeStep_type& FiniteDifferences::
        timeStep () const
        {
          return this->timeStep_.get ();
        }

        FiniteDifferences::timeStep_type& FiniteDifferences::
        timeStep ()
        {
          return this->timeStep_.get ();
        }

        void FiniteDifferences::
        timeStep (const timeStep_type& x)
        {
          this->timeStep_.set (x);
        }


        // Explicit1D
        // 


        // Implicit1D
        // 


        // Explicit2D
        // 


        // Implicit2D
        // 


        // Axis
        // 

        const Axis::from_type& Axis::
        from () const
        {
          return this->from_.get ();
        }

        Axis::from_type& Axis::
        from ()
        {
          return this->from_.get ();
        }

        void Axis::
        from (const from_type& x)
        {
          this->from_.set (x);
        }

        void Axis::
        from (::std::auto_ptr< from_type > x)
        {
          this->from_.set (x);
        }

        const Axis::to_type& Axis::
        to () const
        {
          return this->to_.get ();
        }

        Axis::to_type& Axis::
        to ()
        {
          return this->to_.get ();
        }

        void Axis::
        to (const to_type& x)
        {
          this->to_.set (x);
        }

        void Axis::
        to (::std::auto_ptr< to_type > x)
        {
          this->to_.set (x);
        }


        // ConstantAxisPart
        // 

        const ConstantAxisPart::stepCount_type& ConstantAxisPart::
        stepCount () const
        {
          return this->stepCount_.get ();
        }

        ConstantAxisPart::stepCount_type& ConstantAxisPart::
        stepCount ()
        {
          return this->stepCount_.get ();
        }

        void ConstantAxisPart::
        stepCount (const stepCount_type& x)
        {
          this->stepCount_.set (x);
        }


        // BilinearAxisPart
        // 

        const BilinearAxisPart::startStep_type& BilinearAxisPart::
        startStep () const
        {
          return this->startStep_.get ();
        }

        BilinearAxisPart::startStep_type& BilinearAxisPart::
        startStep ()
        {
          return this->startStep_.get ();
        }

        void BilinearAxisPart::
        startStep (const startStep_type& x)
        {
          this->startStep_.set (x);
        }

        const BilinearAxisPart::factor_type& BilinearAxisPart::
        factor () const
        {
          return this->factor_.get ();
        }

        BilinearAxisPart::factor_type& BilinearAxisPart::
        factor ()
        {
          return this->factor_.get ();
        }

        void BilinearAxisPart::
        factor (const factor_type& x)
        {
          this->factor_.set (x);
        }


        // ConcentrationProfile
        // 

        const ConcentrationProfile::precision_optional& ConcentrationProfile::
        precision () const
        {
          return this->precision_;
        }

        ConcentrationProfile::precision_optional& ConcentrationProfile::
        precision ()
        {
          return this->precision_;
        }

        void ConcentrationProfile::
        precision (const precision_type& x)
        {
          this->precision_.set (x);
        }

        void ConcentrationProfile::
        precision (const precision_optional& x)
        {
          this->precision_ = x;
        }

        const ConcentrationProfile::inMemory_type& ConcentrationProfile::
        inMemory () const
        {
          return this->inMemory_.get ();
        }

        ConcentrationProfile::inMemory_type& ConcentrationProfile::
        inMemory ()
        {
          return this->inMemory_.get ();
        }

        void ConcentrationProfile::
        inMemory (const inMemory_type& x)
        {
          this->inMemory_.set (x);
        }

        ConcentrationProfile::inMemory_type ConcentrationProfile::
        inMemory_default_value ()
        {
          return inMemory_type (false);
        }


        // CurrentDensity
        // 


        // AveragedConcentration
        // 

        const AveragedConcentration::medium_optional& AveragedConcentration::
        medium () const
        {
          return this->medium_;
        }

        AveragedConcentration::medium_optional& AveragedConcentration::
        medium ()
        {
          return this->medium_;
        }

        void AveragedConcentration::
        medium (const medium_type& x)
        {
          this->medium_.set (x);
        }

        void AveragedConcentration::
        medium (const medium_optional& x)
        {
          this->medium_ = x;
        }

        void AveragedConcentration::
        medium (::std::auto_ptr< medium_type > x)
        {
          this->medium_.set (x);
        }


        // SteadyStateHalfTime
        // 


        // SteadyState
        // 

        const SteadyState::output_sequence& SteadyState::
        output () const
        {
          return this->output_;
        }

        SteadyState::output_sequence& SteadyState::
        output ()
        {
          return this->output_;
        }

        void SteadyState::
        output (const output_sequence& s)
        {
          this->output_ = s;
        }


        // Kinetic
        // 

        const Kinetic::output_sequence& Kinetic::
        output () const
        {
          return this->output_;
        }

        Kinetic::output_sequence& Kinetic::
        output ()
        {
          return this->output_;
        }

        void Kinetic::
        output (const output_sequence& s)
        {
          this->output_ = s;
        }

        const Kinetic::stepCount_optional& Kinetic::
        stepCount () const
        {
          return this->stepCount_;
        }

        Kinetic::stepCount_optional& Kinetic::
        stepCount ()
        {
          return this->stepCount_;
        }

        void Kinetic::
        stepCount (const stepCount_type& x)
        {
          this->stepCount_.set (x);
        }

        void Kinetic::
        stepCount (const stepCount_optional& x)
        {
          this->stepCount_ = x;
        }

        const Kinetic::time_optional& Kinetic::
        time () const
        {
          return this->time_;
        }

        Kinetic::time_optional& Kinetic::
        time ()
        {
          return this->time_;
        }

        void Kinetic::
        time (const time_type& x)
        {
          this->time_.set (x);
        }

        void Kinetic::
        time (const time_optional& x)
        {
          this->time_ = x;
        }


        // StopCondition
        // 


        // StopConditionValidAfter
        // 

        const StopConditionValidAfter::stopCondition_sequence& StopConditionValidAfter::
        stopCondition () const
        {
          return this->stopCondition_;
        }

        StopConditionValidAfter::stopCondition_sequence& StopConditionValidAfter::
        stopCondition ()
        {
          return this->stopCondition_;
        }

        void StopConditionValidAfter::
        stopCondition (const stopCondition_sequence& s)
        {
          this->stopCondition_ = s;
        }

        const StopConditionValidAfter::stepCount_optional& StopConditionValidAfter::
        stepCount () const
        {
          return this->stepCount_;
        }

        StopConditionValidAfter::stepCount_optional& StopConditionValidAfter::
        stepCount ()
        {
          return this->stepCount_;
        }

        void StopConditionValidAfter::
        stepCount (const stepCount_type& x)
        {
          this->stepCount_.set (x);
        }

        void StopConditionValidAfter::
        stepCount (const stepCount_optional& x)
        {
          this->stepCount_ = x;
        }

        const StopConditionValidAfter::time_optional& StopConditionValidAfter::
        time () const
        {
          return this->time_;
        }

        StopConditionValidAfter::time_optional& StopConditionValidAfter::
        time ()
        {
          return this->time_;
        }

        void StopConditionValidAfter::
        time (const time_type& x)
        {
          this->time_.set (x);
        }

        void StopConditionValidAfter::
        time (const time_optional& x)
        {
          this->time_ = x;
        }


        // FailIfAbove
        // 

        const FailIfAbove::stepCount_optional& FailIfAbove::
        stepCount () const
        {
          return this->stepCount_;
        }

        FailIfAbove::stepCount_optional& FailIfAbove::
        stepCount ()
        {
          return this->stepCount_;
        }

        void FailIfAbove::
        stepCount (const stepCount_type& x)
        {
          this->stepCount_.set (x);
        }

        void FailIfAbove::
        stepCount (const stepCount_optional& x)
        {
          this->stepCount_ = x;
        }

        const FailIfAbove::time_optional& FailIfAbove::
        time () const
        {
          return this->time_;
        }

        FailIfAbove::time_optional& FailIfAbove::
        time ()
        {
          return this->time_;
        }

        void FailIfAbove::
        time (const time_type& x)
        {
          this->time_.set (x);
        }

        void FailIfAbove::
        time (const time_optional& x)
        {
          this->time_ = x;
        }


        // FailIfInvalidConcentrations
        // 


        // FailOnConcentrationOscillation
        // 


        // FailISumOfConcentrationsNonConst
        // 

        const FailISumOfConcentrationsNonConst::substance_sequence& FailISumOfConcentrationsNonConst::
        substance () const
        {
          return this->substance_;
        }

        FailISumOfConcentrationsNonConst::substance_sequence& FailISumOfConcentrationsNonConst::
        substance ()
        {
          return this->substance_;
        }

        void FailISumOfConcentrationsNonConst::
        substance (const substance_sequence& s)
        {
          this->substance_ = s;
        }

        const FailISumOfConcentrationsNonConst::medium_type& FailISumOfConcentrationsNonConst::
        medium () const
        {
          return this->medium_.get ();
        }

        FailISumOfConcentrationsNonConst::medium_type& FailISumOfConcentrationsNonConst::
        medium ()
        {
          return this->medium_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        medium (const medium_type& x)
        {
          this->medium_.set (x);
        }

        void FailISumOfConcentrationsNonConst::
        medium (::std::auto_ptr< medium_type > x)
        {
          this->medium_.set (x);
        }

        const FailISumOfConcentrationsNonConst::sum_type& FailISumOfConcentrationsNonConst::
        sum () const
        {
          return this->sum_.get ();
        }

        FailISumOfConcentrationsNonConst::sum_type& FailISumOfConcentrationsNonConst::
        sum ()
        {
          return this->sum_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        sum (const sum_type& x)
        {
          this->sum_.set (x);
        }

        void FailISumOfConcentrationsNonConst::
        sum (::std::auto_ptr< sum_type > x)
        {
          this->sum_.set (x);
        }

        const FailISumOfConcentrationsNonConst::error_type& FailISumOfConcentrationsNonConst::
        error () const
        {
          return this->error_.get ();
        }

        FailISumOfConcentrationsNonConst::error_type& FailISumOfConcentrationsNonConst::
        error ()
        {
          return this->error_.get ();
        }

        void FailISumOfConcentrationsNonConst::
        error (const error_type& x)
        {
          this->error_.set (x);
        }


        // CurrentDensityGradient
        // 

        const CurrentDensityGradient::lessThan_type& CurrentDensityGradient::
        lessThan () const
        {
          return this->lessThan_.get ();
        }

        CurrentDensityGradient::lessThan_type& CurrentDensityGradient::
        lessThan ()
        {
          return this->lessThan_.get ();
        }

        void CurrentDensityGradient::
        lessThan (const lessThan_type& x)
        {
          this->lessThan_.set (x);
        }

        const CurrentDensityGradient::normalized_type& CurrentDensityGradient::
        normalized () const
        {
          return this->normalized_.get ();
        }

        CurrentDensityGradient::normalized_type& CurrentDensityGradient::
        normalized ()
        {
          return this->normalized_.get ();
        }

        void CurrentDensityGradient::
        normalized (const normalized_type& x)
        {
          this->normalized_.set (x);
        }


        // TimeStepAdjuster
        // 


        // SimpleTimeStepAdjuster
        // 

        const SimpleTimeStepAdjuster::factor_type& SimpleTimeStepAdjuster::
        factor () const
        {
          return this->factor_.get ();
        }

        SimpleTimeStepAdjuster::factor_type& SimpleTimeStepAdjuster::
        factor ()
        {
          return this->factor_.get ();
        }

        void SimpleTimeStepAdjuster::
        factor (const factor_type& x)
        {
          this->factor_.set (x);
        }

        const SimpleTimeStepAdjuster::everyStepCount_type& SimpleTimeStepAdjuster::
        everyStepCount () const
        {
          return this->everyStepCount_.get ();
        }

        SimpleTimeStepAdjuster::everyStepCount_type& SimpleTimeStepAdjuster::
        everyStepCount ()
        {
          return this->everyStepCount_.get ();
        }

        void SimpleTimeStepAdjuster::
        everyStepCount (const everyStepCount_type& x)
        {
          this->everyStepCount_.set (x);
        }

        const SimpleTimeStepAdjuster::maxStepSize_optional& SimpleTimeStepAdjuster::
        maxStepSize () const
        {
          return this->maxStepSize_;
        }

        SimpleTimeStepAdjuster::maxStepSize_optional& SimpleTimeStepAdjuster::
        maxStepSize ()
        {
          return this->maxStepSize_;
        }

        void SimpleTimeStepAdjuster::
        maxStepSize (const maxStepSize_type& x)
        {
          this->maxStepSize_.set (x);
        }

        void SimpleTimeStepAdjuster::
        maxStepSize (const maxStepSize_optional& x)
        {
          this->maxStepSize_ = x;
        }


        // AdaptiveTimeStepAdjuster
        // 

        const AdaptiveTimeStepAdjuster::increase_type& AdaptiveTimeStepAdjuster::
        increase () const
        {
          return this->increase_.get ();
        }

        AdaptiveTimeStepAdjuster::increase_type& AdaptiveTimeStepAdjuster::
        increase ()
        {
          return this->increase_.get ();
        }

        void AdaptiveTimeStepAdjuster::
        increase (const increase_type& x)
        {
          this->increase_.set (x);
        }

        void AdaptiveTimeStepAdjuster::
        increase (::std::auto_ptr< increase_type > x)
        {
          this->increase_.set (x);
        }

        const AdaptiveTimeStepAdjuster::fallback_type& AdaptiveTimeStepAdjuster::
        fallback () const
        {
          return this->fallback_.get ();
        }

        AdaptiveTimeStepAdjuster::fallback_type& AdaptiveTimeStepAdjuster::
        fallback ()
        {
          return this->fallback_.get ();
        }

        void AdaptiveTimeStepAdjuster::
        fallback (const fallback_type& x)
        {
          this->fallback_.set (x);
        }

        void AdaptiveTimeStepAdjuster::
        fallback (::std::auto_ptr< fallback_type > x)
        {
          this->fallback_.set (x);
        }

        const AdaptiveTimeStepAdjuster::stateStore_type& AdaptiveTimeStepAdjuster::
        stateStore () const
        {
          return this->stateStore_.get ();
        }

        AdaptiveTimeStepAdjuster::stateStore_type& AdaptiveTimeStepAdjuster::
        stateStore ()
        {
          return this->stateStore_.get ();
        }

        void AdaptiveTimeStepAdjuster::
        stateStore (const stateStore_type& x)
        {
          this->stateStore_.set (x);
        }

        void AdaptiveTimeStepAdjuster::
        stateStore (::std::auto_ptr< stateStore_type > x)
        {
          this->stateStore_.set (x);
        }

        const AdaptiveTimeStepAdjuster::stopCondition_sequence& AdaptiveTimeStepAdjuster::
        stopCondition () const
        {
          return this->stopCondition_;
        }

        AdaptiveTimeStepAdjuster::stopCondition_sequence& AdaptiveTimeStepAdjuster::
        stopCondition ()
        {
          return this->stopCondition_;
        }

        void AdaptiveTimeStepAdjuster::
        stopCondition (const stopCondition_sequence& s)
        {
          this->stopCondition_ = s;
        }


        // increase
        // 

        const increase::factor_type& increase::
        factor () const
        {
          return this->factor_.get ();
        }

        increase::factor_type& increase::
        factor ()
        {
          return this->factor_.get ();
        }

        void increase::
        factor (const factor_type& x)
        {
          this->factor_.set (x);
        }

        const increase::everyStepCount_type& increase::
        everyStepCount () const
        {
          return this->everyStepCount_.get ();
        }

        increase::everyStepCount_type& increase::
        everyStepCount ()
        {
          return this->everyStepCount_.get ();
        }

        void increase::
        everyStepCount (const everyStepCount_type& x)
        {
          this->everyStepCount_.set (x);
        }

        const increase::maxStepSize_type& increase::
        maxStepSize () const
        {
          return this->maxStepSize_.get ();
        }

        increase::maxStepSize_type& increase::
        maxStepSize ()
        {
          return this->maxStepSize_.get ();
        }

        void increase::
        maxStepSize (const maxStepSize_type& x)
        {
          this->maxStepSize_.set (x);
        }


        // fallback
        // 

        const fallback::factor_type& fallback::
        factor () const
        {
          return this->factor_.get ();
        }

        fallback::factor_type& fallback::
        factor ()
        {
          return this->factor_.get ();
        }

        void fallback::
        factor (const factor_type& x)
        {
          this->factor_.set (x);
        }

        const fallback::forStepCount_type& fallback::
        forStepCount () const
        {
          return this->forStepCount_.get ();
        }

        fallback::forStepCount_type& fallback::
        forStepCount ()
        {
          return this->forStepCount_.get ();
        }

        void fallback::
        forStepCount (const forStepCount_type& x)
        {
          this->forStepCount_.set (x);
        }

        const fallback::checkEveryStepCount_type& fallback::
        checkEveryStepCount () const
        {
          return this->checkEveryStepCount_.get ();
        }

        fallback::checkEveryStepCount_type& fallback::
        checkEveryStepCount ()
        {
          return this->checkEveryStepCount_.get ();
        }

        void fallback::
        checkEveryStepCount (const checkEveryStepCount_type& x)
        {
          this->checkEveryStepCount_.set (x);
        }

        const fallback::minStepSize_type& fallback::
        minStepSize () const
        {
          return this->minStepSize_.get ();
        }

        fallback::minStepSize_type& fallback::
        minStepSize ()
        {
          return this->minStepSize_.get ();
        }

        void fallback::
        minStepSize (const minStepSize_type& x)
        {
          this->minStepSize_.set (x);
        }
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        // FiniteDifferences
        //

        FiniteDifferences::
        FiniteDifferences (const timeStep_type& timeStep)
        : ::bio::xml::model::Solver (),
          axis_ (::xml_schema::flags (), this),
          stopCondition_ (::xml_schema::flags (), this),
          timeStepAdjuster_ (::xml_schema::flags (), this),
          timeStep_ (timeStep, ::xml_schema::flags (), this)
        {
        }

        FiniteDifferences::
        FiniteDifferences (const FiniteDifferences& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
        : ::bio::xml::model::Solver (x, f, c),
          axis_ (x.axis_, f, this),
          stopCondition_ (x.stopCondition_, f, this),
          timeStepAdjuster_ (x.timeStepAdjuster_, f, this),
          timeStep_ (x.timeStep_, f, this)
        {
        }

        FiniteDifferences::
        FiniteDifferences (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
        : ::bio::xml::model::Solver (e, f | ::xml_schema::flags::base, c),
          axis_ (f, this),
          stopCondition_ (f, this),
          timeStepAdjuster_ (f, this),
          timeStep_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
            this->parse (p, f);
          }
        }

        void FiniteDifferences::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::Solver::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // axis
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "axis",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< axis_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< axis_type > r (
                  dynamic_cast< axis_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->axis_.push_back (r);
                continue;
              }
            }

            // stopCondition
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stopCondition_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< stopCondition_type > r (
                  dynamic_cast< stopCondition_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->stopCondition_.push_back (r);
                continue;
              }
            }

            // timeStepAdjuster
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "timeStepAdjuster",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< timeStepAdjuster_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!this->timeStepAdjuster_)
                {
                  ::std::auto_ptr< timeStepAdjuster_type > r (
                    dynamic_cast< timeStepAdjuster_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->timeStepAdjuster_.set (r);
                  continue;
                }
              }
            }

            break;
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "timeStep" && n.namespace_ ().empty ())
            {
              this->timeStep_.set (timeStep_traits::create (i, f, this));
              continue;
            }
          }

          if (!timeStep_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "timeStep",
              "");
          }
        }

        FiniteDifferences* FiniteDifferences::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FiniteDifferences (*this, f, c);
        }

        FiniteDifferences::
        ~FiniteDifferences ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FiniteDifferences >
        _xsd_FiniteDifferences_type_factory_init (
          "FiniteDifferences",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Explicit1D
        //

        Explicit1D::
        Explicit1D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Explicit1D::
        Explicit1D (const Explicit1D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Explicit1D::
        Explicit1D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Explicit1D* Explicit1D::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Explicit1D (*this, f, c);
        }

        Explicit1D::
        ~Explicit1D ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Explicit1D >
        _xsd_Explicit1D_type_factory_init (
          "Explicit1D",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Implicit1D
        //

        Implicit1D::
        Implicit1D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Implicit1D::
        Implicit1D (const Implicit1D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Implicit1D::
        Implicit1D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Implicit1D* Implicit1D::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Implicit1D (*this, f, c);
        }

        Implicit1D::
        ~Implicit1D ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Implicit1D >
        _xsd_Implicit1D_type_factory_init (
          "Implicit1D",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Explicit2D
        //

        Explicit2D::
        Explicit2D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Explicit2D::
        Explicit2D (const Explicit2D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Explicit2D::
        Explicit2D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Explicit2D* Explicit2D::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Explicit2D (*this, f, c);
        }

        Explicit2D::
        ~Explicit2D ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Explicit2D >
        _xsd_Explicit2D_type_factory_init (
          "Explicit2D",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Implicit2D
        //

        Implicit2D::
        Implicit2D (const timeStep_type& timeStep)
        : ::bio::xml::model::solver::FiniteDifferences (timeStep)
        {
        }

        Implicit2D::
        Implicit2D (const Implicit2D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (x, f, c)
        {
        }

        Implicit2D::
        Implicit2D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
        : ::bio::xml::model::solver::FiniteDifferences (e, f, c)
        {
        }

        Implicit2D* Implicit2D::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Implicit2D (*this, f, c);
        }

        Implicit2D::
        ~Implicit2D ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Implicit2D >
        _xsd_Implicit2D_type_factory_init (
          "Implicit2D",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Axis
        //

        Axis::
        Axis (const from_type& from,
              const to_type& to)
        : ::xml_schema::type (),
          from_ (from, ::xml_schema::flags (), this),
          to_ (to, ::xml_schema::flags (), this)
        {
        }

        Axis::
        Axis (const Axis& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c),
          from_ (x.from_, f, this),
          to_ (x.to_, f, this)
        {
        }

        Axis::
        Axis (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          from_ (f, this),
          to_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void Axis::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "from" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< from_type > r (
                from_traits::create (i, f, this));

              this->from_.set (r);
              continue;
            }

            if (n.name () == "to" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< to_type > r (
                to_traits::create (i, f, this));

              this->to_.set (r);
              continue;
            }
          }

          if (!from_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "from",
              "");
          }

          if (!to_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "to",
              "");
          }
        }

        Axis* Axis::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Axis (*this, f, c);
        }

        Axis::
        ~Axis ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Axis >
        _xsd_Axis_type_factory_init (
          "Axis",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // ConstantAxisPart
        //

        ConstantAxisPart::
        ConstantAxisPart (const from_type& from,
                          const to_type& to,
                          const stepCount_type& stepCount)
        : ::bio::xml::model::solver::Axis (from,
                                           to),
          stepCount_ (stepCount, ::xml_schema::flags (), this)
        {
        }

        ConstantAxisPart::
        ConstantAxisPart (const ConstantAxisPart& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::Axis (x, f, c),
          stepCount_ (x.stepCount_, f, this)
        {
        }

        ConstantAxisPart::
        ConstantAxisPart (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::Axis (e, f | ::xml_schema::flags::base, c),
          stepCount_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void ConstantAxisPart::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::solver::Axis::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount_.set (stepCount_traits::create (i, f, this));
              continue;
            }
          }

          if (!stepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "stepCount",
              "");
          }
        }

        ConstantAxisPart* ConstantAxisPart::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ConstantAxisPart (*this, f, c);
        }

        ConstantAxisPart::
        ~ConstantAxisPart ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConstantAxisPart >
        _xsd_ConstantAxisPart_type_factory_init (
          "ConstantAxisPart",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // BilinearAxisPart
        //

        BilinearAxisPart::
        BilinearAxisPart (const from_type& from,
                          const to_type& to,
                          const startStep_type& startStep,
                          const factor_type& factor)
        : ::bio::xml::model::solver::Axis (from,
                                           to),
          startStep_ (startStep, ::xml_schema::flags (), this),
          factor_ (factor, ::xml_schema::flags (), this)
        {
        }

        BilinearAxisPart::
        BilinearAxisPart (const BilinearAxisPart& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::Axis (x, f, c),
          startStep_ (x.startStep_, f, this),
          factor_ (x.factor_, f, this)
        {
        }

        BilinearAxisPart::
        BilinearAxisPart (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::Axis (e, f | ::xml_schema::flags::base, c),
          startStep_ (f, this),
          factor_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void BilinearAxisPart::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::solver::Axis::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "startStep" && n.namespace_ ().empty ())
            {
              this->startStep_.set (startStep_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor_.set (factor_traits::create (i, f, this));
              continue;
            }
          }

          if (!startStep_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "startStep",
              "");
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }
        }

        BilinearAxisPart* BilinearAxisPart::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class BilinearAxisPart (*this, f, c);
        }

        BilinearAxisPart::
        ~BilinearAxisPart ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, BilinearAxisPart >
        _xsd_BilinearAxisPart_type_factory_init (
          "BilinearAxisPart",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // ConcentrationProfile
        //

        ConcentrationProfile::
        ConcentrationProfile (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          precision_ (::xml_schema::flags (), this),
          inMemory_ (inMemory_default_value (), ::xml_schema::flags (), this)
        {
        }

        ConcentrationProfile::
        ConcentrationProfile (const ConcentrationProfile& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          precision_ (x.precision_, f, this),
          inMemory_ (x.inMemory_, f, this)
        {
        }

        ConcentrationProfile::
        ConcentrationProfile (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          precision_ (f, this),
          inMemory_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void ConcentrationProfile::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "precision" && n.namespace_ ().empty ())
            {
              this->precision_.set (precision_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "inMemory" && n.namespace_ ().empty ())
            {
              this->inMemory_.set (inMemory_traits::create (i, f, this));
              continue;
            }
          }

          if (!inMemory_.present ())
          {
            this->inMemory_.set (inMemory_default_value ());
          }
        }

        ConcentrationProfile* ConcentrationProfile::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class ConcentrationProfile (*this, f, c);
        }

        ConcentrationProfile::
        ~ConcentrationProfile ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConcentrationProfile >
        _xsd_ConcentrationProfile_type_factory_init (
          "ConcentrationProfile",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // CurrentDensity
        //

        CurrentDensity::
        CurrentDensity (const name_type& name)
        : ::bio::xml::model::SolverOutput (name)
        {
        }

        CurrentDensity::
        CurrentDensity (const CurrentDensity& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c)
        {
        }

        CurrentDensity::
        CurrentDensity (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f, c)
        {
        }

        CurrentDensity* CurrentDensity::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CurrentDensity (*this, f, c);
        }

        CurrentDensity::
        ~CurrentDensity ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CurrentDensity >
        _xsd_CurrentDensity_type_factory_init (
          "CurrentDensity",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // AveragedConcentration
        //

        AveragedConcentration::
        AveragedConcentration (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          medium_ (::xml_schema::flags (), this)
        {
        }

        AveragedConcentration::
        AveragedConcentration (const AveragedConcentration& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          medium_ (x.medium_, f, this)
        {
        }

        AveragedConcentration::
        AveragedConcentration (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          medium_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void AveragedConcentration::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "medium" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< medium_type > r (
                medium_traits::create (i, f, this));

              this->medium_.set (r);
              continue;
            }
          }
        }

        AveragedConcentration* AveragedConcentration::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class AveragedConcentration (*this, f, c);
        }

        AveragedConcentration::
        ~AveragedConcentration ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, AveragedConcentration >
        _xsd_AveragedConcentration_type_factory_init (
          "AveragedConcentration",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // SteadyStateHalfTime
        //

        SteadyStateHalfTime::
        SteadyStateHalfTime (const name_type& name)
        : ::bio::xml::model::SolverOutput (name)
        {
        }

        SteadyStateHalfTime::
        SteadyStateHalfTime (const SteadyStateHalfTime& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c)
        {
        }

        SteadyStateHalfTime::
        SteadyStateHalfTime (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f, c)
        {
        }

        SteadyStateHalfTime* SteadyStateHalfTime::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class SteadyStateHalfTime (*this, f, c);
        }

        SteadyStateHalfTime::
        ~SteadyStateHalfTime ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, SteadyStateHalfTime >
        _xsd_SteadyStateHalfTime_type_factory_init (
          "SteadyStateHalfTime",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // SteadyState
        //

        SteadyState::
        SteadyState (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          output_ (::xml_schema::flags (), this)
        {
        }

        SteadyState::
        SteadyState (const SteadyState& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          output_ (x.output_, f, this)
        {
        }

        SteadyState::
        SteadyState (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          output_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
            this->parse (p, f);
          }
        }

        void SteadyState::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // output
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "output",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< output_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< output_type > r (
                  dynamic_cast< output_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->output_.push_back (r);
                continue;
              }
            }

            break;
          }
        }

        SteadyState* SteadyState::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class SteadyState (*this, f, c);
        }

        SteadyState::
        ~SteadyState ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, SteadyState >
        _xsd_SteadyState_type_factory_init (
          "SteadyState",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // Kinetic
        //

        Kinetic::
        Kinetic (const name_type& name)
        : ::bio::xml::model::SolverOutput (name),
          output_ (::xml_schema::flags (), this),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        Kinetic::
        Kinetic (const Kinetic& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (x, f, c),
          output_ (x.output_, f, this),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        Kinetic::
        Kinetic (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
        : ::bio::xml::model::SolverOutput (e, f | ::xml_schema::flags::base, c),
          output_ (f, this),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
            this->parse (p, f);
          }
        }

        void Kinetic::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          this->::bio::xml::model::SolverOutput::parse (p, f);

          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // output
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "output",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< output_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< output_type > r (
                  dynamic_cast< output_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->output_.push_back (r);
                continue;
              }
            }

            break;
          }

          p.reset_attributes ();

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount_.set (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time_.set (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        Kinetic* Kinetic::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class Kinetic (*this, f, c);
        }

        Kinetic::
        ~Kinetic ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, Kinetic >
        _xsd_Kinetic_type_factory_init (
          "Kinetic",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // StopCondition
        //

        StopCondition::
        StopCondition ()
        : ::xml_schema::type ()
        {
        }

        StopCondition::
        StopCondition (const StopCondition& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::type (e, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::type (a, f, c)
        {
        }

        StopCondition::
        StopCondition (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
        : ::xml_schema::type (s, e, f, c)
        {
        }

        StopCondition* StopCondition::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class StopCondition (*this, f, c);
        }

        StopCondition::
        ~StopCondition ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopCondition >
        _xsd_StopCondition_type_factory_init (
          "StopCondition",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // StopConditionValidAfter
        //

        StopConditionValidAfter::
        StopConditionValidAfter ()
        : ::bio::xml::model::solver::StopCondition (),
          stopCondition_ (::xml_schema::flags (), this),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        StopConditionValidAfter::
        StopConditionValidAfter (const StopConditionValidAfter& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          stopCondition_ (x.stopCondition_, f, this),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        StopConditionValidAfter::
        StopConditionValidAfter (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          stopCondition_ (f, this),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
            this->parse (p, f);
          }
        }

        void StopConditionValidAfter::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // stopCondition
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stopCondition_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< stopCondition_type > r (
                  dynamic_cast< stopCondition_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->stopCondition_.push_back (r);
                continue;
              }
            }

            break;
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount_.set (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time_.set (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        StopConditionValidAfter* StopConditionValidAfter::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class StopConditionValidAfter (*this, f, c);
        }

        StopConditionValidAfter::
        ~StopConditionValidAfter ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, StopConditionValidAfter >
        _xsd_StopConditionValidAfter_type_factory_init (
          "StopConditionValidAfter",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // FailIfAbove
        //

        FailIfAbove::
        FailIfAbove ()
        : ::bio::xml::model::solver::StopCondition (),
          stepCount_ (::xml_schema::flags (), this),
          time_ (::xml_schema::flags (), this)
        {
        }

        FailIfAbove::
        FailIfAbove (const FailIfAbove& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          stepCount_ (x.stepCount_, f, this),
          time_ (x.time_, f, this)
        {
        }

        FailIfAbove::
        FailIfAbove (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          stepCount_ (f, this),
          time_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void FailIfAbove::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "stepCount" && n.namespace_ ().empty ())
            {
              this->stepCount_.set (stepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "time" && n.namespace_ ().empty ())
            {
              this->time_.set (time_traits::create (i, f, this));
              continue;
            }
          }
        }

        FailIfAbove* FailIfAbove::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FailIfAbove (*this, f, c);
        }

        FailIfAbove::
        ~FailIfAbove ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FailIfAbove >
        _xsd_FailIfAbove_type_factory_init (
          "FailIfAbove",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // FailIfInvalidConcentrations
        //

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations ()
        : ::bio::xml::model::solver::StopCondition ()
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const FailIfInvalidConcentrations& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (a, f, c)
        {
        }

        FailIfInvalidConcentrations::
        FailIfInvalidConcentrations (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (s, e, f, c)
        {
        }

        FailIfInvalidConcentrations* FailIfInvalidConcentrations::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FailIfInvalidConcentrations (*this, f, c);
        }

        FailIfInvalidConcentrations::
        ~FailIfInvalidConcentrations ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FailIfInvalidConcentrations >
        _xsd_FailIfInvalidConcentrations_type_factory_init (
          "FailIfInvalidConcentrations",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // FailOnConcentrationOscillation
        //

        FailOnConcentrationOscillation::
        FailOnConcentrationOscillation ()
        : ::bio::xml::model::solver::StopCondition ()
        {
        }

        FailOnConcentrationOscillation::
        FailOnConcentrationOscillation (const FailOnConcentrationOscillation& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c)
        {
        }

        FailOnConcentrationOscillation::
        FailOnConcentrationOscillation (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f, c)
        {
        }

        FailOnConcentrationOscillation::
        FailOnConcentrationOscillation (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (a, f, c)
        {
        }

        FailOnConcentrationOscillation::
        FailOnConcentrationOscillation (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (s, e, f, c)
        {
        }

        FailOnConcentrationOscillation* FailOnConcentrationOscillation::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FailOnConcentrationOscillation (*this, f, c);
        }

        FailOnConcentrationOscillation::
        ~FailOnConcentrationOscillation ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FailOnConcentrationOscillation >
        _xsd_FailOnConcentrationOscillation_type_factory_init (
          "FailOnConcentrationOscillation",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // FailISumOfConcentrationsNonConst
        //

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const medium_type& medium,
                                          const sum_type& sum,
                                          const error_type& error)
        : ::bio::xml::model::solver::StopCondition (),
          substance_ (::xml_schema::flags (), this),
          medium_ (medium, ::xml_schema::flags (), this),
          sum_ (sum, ::xml_schema::flags (), this),
          error_ (error, ::xml_schema::flags (), this)
        {
        }

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const FailISumOfConcentrationsNonConst& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          substance_ (x.substance_, f, this),
          medium_ (x.medium_, f, this),
          sum_ (x.sum_, f, this),
          error_ (x.error_, f, this)
        {
        }

        FailISumOfConcentrationsNonConst::
        FailISumOfConcentrationsNonConst (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          substance_ (f, this),
          medium_ (f, this),
          sum_ (f, this),
          error_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
            this->parse (p, f);
          }
        }

        void FailISumOfConcentrationsNonConst::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // substance
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "substance",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< substance_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< substance_type > r (
                  dynamic_cast< substance_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->substance_.push_back (r);
                continue;
              }
            }

            break;
          }

          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "medium" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< medium_type > r (
                medium_traits::create (i, f, this));

              this->medium_.set (r);
              continue;
            }

            if (n.name () == "sum" && n.namespace_ ().empty ())
            {
              ::std::auto_ptr< sum_type > r (
                sum_traits::create (i, f, this));

              this->sum_.set (r);
              continue;
            }

            if (n.name () == "error" && n.namespace_ ().empty ())
            {
              this->error_.set (error_traits::create (i, f, this));
              continue;
            }
          }

          if (!medium_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "medium",
              "");
          }

          if (!sum_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "sum",
              "");
          }

          if (!error_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "error",
              "");
          }
        }

        FailISumOfConcentrationsNonConst* FailISumOfConcentrationsNonConst::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class FailISumOfConcentrationsNonConst (*this, f, c);
        }

        FailISumOfConcentrationsNonConst::
        ~FailISumOfConcentrationsNonConst ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, FailISumOfConcentrationsNonConst >
        _xsd_FailISumOfConcentrationsNonConst_type_factory_init (
          "FailISumOfConcentrationsNonConst",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // CurrentDensityGradient
        //

        CurrentDensityGradient::
        CurrentDensityGradient (const lessThan_type& lessThan,
                                const normalized_type& normalized)
        : ::bio::xml::model::solver::StopCondition (),
          lessThan_ (lessThan, ::xml_schema::flags (), this),
          normalized_ (normalized, ::xml_schema::flags (), this)
        {
        }

        CurrentDensityGradient::
        CurrentDensityGradient (const CurrentDensityGradient& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (x, f, c),
          lessThan_ (x.lessThan_, f, this),
          normalized_ (x.normalized_, f, this)
        {
        }

        CurrentDensityGradient::
        CurrentDensityGradient (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::bio::xml::model::solver::StopCondition (e, f | ::xml_schema::flags::base, c),
          lessThan_ (f, this),
          normalized_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void CurrentDensityGradient::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "lessThan" && n.namespace_ ().empty ())
            {
              this->lessThan_.set (lessThan_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "normalized" && n.namespace_ ().empty ())
            {
              this->normalized_.set (normalized_traits::create (i, f, this));
              continue;
            }
          }

          if (!lessThan_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "lessThan",
              "");
          }

          if (!normalized_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "normalized",
              "");
          }
        }

        CurrentDensityGradient* CurrentDensityGradient::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class CurrentDensityGradient (*this, f, c);
        }

        CurrentDensityGradient::
        ~CurrentDensityGradient ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, CurrentDensityGradient >
        _xsd_CurrentDensityGradient_type_factory_init (
          "CurrentDensityGradient",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // TimeStepAdjuster
        //

        TimeStepAdjuster::
        TimeStepAdjuster ()
        : ::xml_schema::type ()
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const TimeStepAdjuster& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::type (e, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::type (a, f, c)
        {
        }

        TimeStepAdjuster::
        TimeStepAdjuster (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
        : ::xml_schema::type (s, e, f, c)
        {
        }

        TimeStepAdjuster* TimeStepAdjuster::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class TimeStepAdjuster (*this, f, c);
        }

        TimeStepAdjuster::
        ~TimeStepAdjuster ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeStepAdjuster >
        _xsd_TimeStepAdjuster_type_factory_init (
          "TimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // SimpleTimeStepAdjuster
        //

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const factor_type& factor,
                                const everyStepCount_type& everyStepCount)
        : ::bio::xml::model::solver::TimeStepAdjuster (),
          factor_ (factor, ::xml_schema::flags (), this),
          everyStepCount_ (everyStepCount, ::xml_schema::flags (), this),
          maxStepSize_ (::xml_schema::flags (), this)
        {
        }

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const SimpleTimeStepAdjuster& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (x, f, c),
          factor_ (x.factor_, f, this),
          everyStepCount_ (x.everyStepCount_, f, this),
          maxStepSize_ (x.maxStepSize_, f, this)
        {
        }

        SimpleTimeStepAdjuster::
        SimpleTimeStepAdjuster (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (e, f | ::xml_schema::flags::base, c),
          factor_ (f, this),
          everyStepCount_ (f, this),
          maxStepSize_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void SimpleTimeStepAdjuster::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor_.set (factor_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "everyStepCount" && n.namespace_ ().empty ())
            {
              this->everyStepCount_.set (everyStepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "maxStepSize" && n.namespace_ ().empty ())
            {
              this->maxStepSize_.set (maxStepSize_traits::create (i, f, this));
              continue;
            }
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }

          if (!everyStepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "everyStepCount",
              "");
          }
        }

        SimpleTimeStepAdjuster* SimpleTimeStepAdjuster::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class SimpleTimeStepAdjuster (*this, f, c);
        }

        SimpleTimeStepAdjuster::
        ~SimpleTimeStepAdjuster ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, SimpleTimeStepAdjuster >
        _xsd_SimpleTimeStepAdjuster_type_factory_init (
          "SimpleTimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // AdaptiveTimeStepAdjuster
        //

        AdaptiveTimeStepAdjuster::
        AdaptiveTimeStepAdjuster (const increase_type& increase,
                                  const fallback_type& fallback,
                                  const stateStore_type& stateStore)
        : ::bio::xml::model::solver::TimeStepAdjuster (),
          increase_ (increase, ::xml_schema::flags (), this),
          fallback_ (fallback, ::xml_schema::flags (), this),
          stateStore_ (stateStore, ::xml_schema::flags (), this),
          stopCondition_ (::xml_schema::flags (), this)
        {
        }

        AdaptiveTimeStepAdjuster::
        AdaptiveTimeStepAdjuster (::std::auto_ptr< increase_type >& increase,
                                  ::std::auto_ptr< fallback_type >& fallback,
                                  ::std::auto_ptr< stateStore_type >& stateStore)
        : ::bio::xml::model::solver::TimeStepAdjuster (),
          increase_ (increase, ::xml_schema::flags (), this),
          fallback_ (fallback, ::xml_schema::flags (), this),
          stateStore_ (stateStore, ::xml_schema::flags (), this),
          stopCondition_ (::xml_schema::flags (), this)
        {
        }

        AdaptiveTimeStepAdjuster::
        AdaptiveTimeStepAdjuster (const AdaptiveTimeStepAdjuster& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (x, f, c),
          increase_ (x.increase_, f, this),
          fallback_ (x.fallback_, f, this),
          stateStore_ (x.stateStore_, f, this),
          stopCondition_ (x.stopCondition_, f, this)
        {
        }

        AdaptiveTimeStepAdjuster::
        AdaptiveTimeStepAdjuster (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
        : ::bio::xml::model::solver::TimeStepAdjuster (e, f | ::xml_schema::flags::base, c),
          increase_ (f, this),
          fallback_ (f, this),
          stateStore_ (f, this),
          stopCondition_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
            this->parse (p, f);
          }
        }

        void AdaptiveTimeStepAdjuster::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          for (; p.more_elements (); p.next_element ())
          {
            const ::xercesc::DOMElement& i (p.cur_element ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            // increase
            //
            if (n.name () == "increase" && n.namespace_ () == "http://karolis.5grupe.lt/biosensor/model/solver")
            {
              ::std::auto_ptr< increase_type > r (
                increase_traits::create (i, f, this));

              if (!increase_.present ())
              {
                this->increase_.set (r);
                continue;
              }
            }

            // fallback
            //
            if (n.name () == "fallback" && n.namespace_ () == "http://karolis.5grupe.lt/biosensor/model/solver")
            {
              ::std::auto_ptr< fallback_type > r (
                fallback_traits::create (i, f, this));

              if (!fallback_.present ())
              {
                this->fallback_.set (r);
                continue;
              }
            }

            // stateStore
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "stateStore",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stateStore_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                if (!stateStore_.present ())
                {
                  ::std::auto_ptr< stateStore_type > r (
                    dynamic_cast< stateStore_type* > (tmp.get ()));

                  if (r.get ())
                    tmp.release ();
                  else
                    throw ::xsd::cxx::tree::not_derived< char > ();

                  this->stateStore_.set (r);
                  continue;
                }
              }
            }

            // stopCondition
            //
            {
              ::xsd::cxx::tree::type_factory_map< char >& tfm (
                ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

              ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
                tfm.create (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  &::xsd::cxx::tree::factory_impl< stopCondition_type >,
                  false, true, i, n, f, this));

              if (tmp.get () != 0)
              {
                ::std::auto_ptr< stopCondition_type > r (
                  dynamic_cast< stopCondition_type* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->stopCondition_.push_back (r);
                continue;
              }
            }

            break;
          }

          if (!increase_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "increase",
              "http://karolis.5grupe.lt/biosensor/model/solver");
          }

          if (!fallback_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "fallback",
              "http://karolis.5grupe.lt/biosensor/model/solver");
          }

          if (!stateStore_.present ())
          {
            throw ::xsd::cxx::tree::expected_element< char > (
              "stateStore",
              "http://karolis.5grupe.lt/biosensor/model/solver");
          }
        }

        AdaptiveTimeStepAdjuster* AdaptiveTimeStepAdjuster::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class AdaptiveTimeStepAdjuster (*this, f, c);
        }

        AdaptiveTimeStepAdjuster::
        ~AdaptiveTimeStepAdjuster ()
        {
        }

        static
        const ::xsd::cxx::tree::type_factory_initializer< 0, char, AdaptiveTimeStepAdjuster >
        _xsd_AdaptiveTimeStepAdjuster_type_factory_init (
          "AdaptiveTimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");

        // increase
        //

        increase::
        increase (const factor_type& factor,
                  const everyStepCount_type& everyStepCount,
                  const maxStepSize_type& maxStepSize)
        : ::xml_schema::type (),
          factor_ (factor, ::xml_schema::flags (), this),
          everyStepCount_ (everyStepCount, ::xml_schema::flags (), this),
          maxStepSize_ (maxStepSize, ::xml_schema::flags (), this)
        {
        }

        increase::
        increase (const increase& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c),
          factor_ (x.factor_, f, this),
          everyStepCount_ (x.everyStepCount_, f, this),
          maxStepSize_ (x.maxStepSize_, f, this)
        {
        }

        increase::
        increase (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          factor_ (f, this),
          everyStepCount_ (f, this),
          maxStepSize_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void increase::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor_.set (factor_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "everyStepCount" && n.namespace_ ().empty ())
            {
              this->everyStepCount_.set (everyStepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "maxStepSize" && n.namespace_ ().empty ())
            {
              this->maxStepSize_.set (maxStepSize_traits::create (i, f, this));
              continue;
            }
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }

          if (!everyStepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "everyStepCount",
              "");
          }

          if (!maxStepSize_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "maxStepSize",
              "");
          }
        }

        increase* increase::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class increase (*this, f, c);
        }

        increase::
        ~increase ()
        {
        }

        // fallback
        //

        fallback::
        fallback (const factor_type& factor,
                  const forStepCount_type& forStepCount,
                  const checkEveryStepCount_type& checkEveryStepCount,
                  const minStepSize_type& minStepSize)
        : ::xml_schema::type (),
          factor_ (factor, ::xml_schema::flags (), this),
          forStepCount_ (forStepCount, ::xml_schema::flags (), this),
          checkEveryStepCount_ (checkEveryStepCount, ::xml_schema::flags (), this),
          minStepSize_ (minStepSize, ::xml_schema::flags (), this)
        {
        }

        fallback::
        fallback (const fallback& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c),
          factor_ (x.factor_, f, this),
          forStepCount_ (x.forStepCount_, f, this),
          checkEveryStepCount_ (x.checkEveryStepCount_, f, this),
          minStepSize_ (x.minStepSize_, f, this)
        {
        }

        fallback::
        fallback (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          factor_ (f, this),
          forStepCount_ (f, this),
          checkEveryStepCount_ (f, this),
          minStepSize_ (f, this)
        {
          if ((f & ::xml_schema::flags::base) == 0)
          {
            ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
            this->parse (p, f);
          }
        }

        void fallback::
        parse (::xsd::cxx::xml::dom::parser< char >& p,
               ::xml_schema::flags f)
        {
          while (p.more_attributes ())
          {
            const ::xercesc::DOMAttr& i (p.next_attribute ());
            const ::xsd::cxx::xml::qualified_name< char > n (
              ::xsd::cxx::xml::dom::name< char > (i));

            if (n.name () == "factor" && n.namespace_ ().empty ())
            {
              this->factor_.set (factor_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "forStepCount" && n.namespace_ ().empty ())
            {
              this->forStepCount_.set (forStepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "checkEveryStepCount" && n.namespace_ ().empty ())
            {
              this->checkEveryStepCount_.set (checkEveryStepCount_traits::create (i, f, this));
              continue;
            }

            if (n.name () == "minStepSize" && n.namespace_ ().empty ())
            {
              this->minStepSize_.set (minStepSize_traits::create (i, f, this));
              continue;
            }
          }

          if (!factor_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "factor",
              "");
          }

          if (!forStepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "forStepCount",
              "");
          }

          if (!checkEveryStepCount_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "checkEveryStepCount",
              "");
          }

          if (!minStepSize_.present ())
          {
            throw ::xsd::cxx::tree::expected_attribute< char > (
              "minStepSize",
              "");
          }
        }

        fallback* fallback::
        _clone (::xml_schema::flags f,
                ::xml_schema::container* c) const
        {
          return new class fallback (*this, f, c);
        }

        fallback::
        ~fallback ()
        {
        }
      }
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
      }
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace bio
{
  namespace xml
  {
    namespace model
    {
      namespace solver
      {
        void
        operator<< (::xercesc::DOMElement& e, const FiniteDifferences& i)
        {
          e << static_cast< const ::bio::xml::model::Solver& > (i);

          // axis
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FiniteDifferences::axis_const_iterator
                 b (i.axis ().begin ()), n (i.axis ().end ());
                 b != n; ++b)
            {
              if (typeid (FiniteDifferences::axis_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "axis",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "axis",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stopCondition
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FiniteDifferences::stopCondition_const_iterator
                 b (i.stopCondition ().begin ()), n (i.stopCondition ().end ());
                 b != n; ++b)
            {
              if (typeid (FiniteDifferences::stopCondition_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "stopCondition",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // timeStepAdjuster
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            if (i.timeStepAdjuster ())
            {
              const FiniteDifferences::timeStepAdjuster_type& x (*i.timeStepAdjuster ());
              if (typeid (FiniteDifferences::timeStepAdjuster_type) == typeid (x))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "timeStepAdjuster",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << x;
              }
              else
                tsm.serialize (
                  "timeStepAdjuster",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, x);
            }
          }

          // timeStep
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "timeStep",
                e));

            a << ::xml_schema::as_double(i.timeStep ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FiniteDifferences >
        _xsd_FiniteDifferences_type_serializer_init (
          "FiniteDifferences",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Explicit1D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Explicit1D >
        _xsd_Explicit1D_type_serializer_init (
          "Explicit1D",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Implicit1D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Implicit1D >
        _xsd_Implicit1D_type_serializer_init (
          "Implicit1D",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Explicit2D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Explicit2D >
        _xsd_Explicit2D_type_serializer_init (
          "Explicit2D",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Implicit2D& i)
        {
          e << static_cast< const ::bio::xml::model::solver::FiniteDifferences& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Implicit2D >
        _xsd_Implicit2D_type_serializer_init (
          "Implicit2D",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Axis& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);

          // from
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "from",
                e));

            a << i.from ();
          }

          // to
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "to",
                e));

            a << i.to ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Axis >
        _xsd_Axis_type_serializer_init (
          "Axis",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const ConstantAxisPart& i)
        {
          e << static_cast< const ::bio::xml::model::solver::Axis& > (i);

          // stepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << i.stepCount ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConstantAxisPart >
        _xsd_ConstantAxisPart_type_serializer_init (
          "ConstantAxisPart",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const BilinearAxisPart& i)
        {
          e << static_cast< const ::bio::xml::model::solver::Axis& > (i);

          // startStep
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "startStep",
                e));

            a << ::xml_schema::as_double(i.startStep ());
          }

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << ::xml_schema::as_double(i.factor ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BilinearAxisPart >
        _xsd_BilinearAxisPart_type_serializer_init (
          "BilinearAxisPart",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const ConcentrationProfile& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // precision
          //
          if (i.precision ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "precision",
                e));

            a << *i.precision ();
          }

          // inMemory
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "inMemory",
                e));

            a << i.inMemory ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConcentrationProfile >
        _xsd_ConcentrationProfile_type_serializer_init (
          "ConcentrationProfile",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const CurrentDensity& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CurrentDensity >
        _xsd_CurrentDensity_type_serializer_init (
          "CurrentDensity",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const AveragedConcentration& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // medium
          //
          if (i.medium ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "medium",
                e));

            a << *i.medium ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AveragedConcentration >
        _xsd_AveragedConcentration_type_serializer_init (
          "AveragedConcentration",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SteadyStateHalfTime& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SteadyStateHalfTime >
        _xsd_SteadyStateHalfTime_type_serializer_init (
          "SteadyStateHalfTime",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SteadyState& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // output
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (SteadyState::output_const_iterator
                 b (i.output ().begin ()), n (i.output ().end ());
                 b != n; ++b)
            {
              if (typeid (SteadyState::output_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "output",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "output",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SteadyState >
        _xsd_SteadyState_type_serializer_init (
          "SteadyState",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const Kinetic& i)
        {
          e << static_cast< const ::bio::xml::model::SolverOutput& > (i);

          // output
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (Kinetic::output_const_iterator
                 b (i.output ().begin ()), n (i.output ().end ());
                 b != n; ++b)
            {
              if (typeid (Kinetic::output_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "output",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "output",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << ::xml_schema::as_double(*i.time ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Kinetic >
        _xsd_Kinetic_type_serializer_init (
          "Kinetic",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const StopCondition& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr&, const StopCondition&)
        {
        }

        void
        operator<< (::xml_schema::list_stream&,
                    const StopCondition&)
        {
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopCondition >
        _xsd_StopCondition_type_serializer_init (
          "StopCondition",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const StopConditionValidAfter& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // stopCondition
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (StopConditionValidAfter::stopCondition_const_iterator
                 b (i.stopCondition ().begin ()), n (i.stopCondition ().end ());
                 b != n; ++b)
            {
              if (typeid (StopConditionValidAfter::stopCondition_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "stopCondition",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << ::xml_schema::as_double(*i.time ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StopConditionValidAfter >
        _xsd_StopConditionValidAfter_type_serializer_init (
          "StopConditionValidAfter",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailIfAbove& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // stepCount
          //
          if (i.stepCount ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "stepCount",
                e));

            a << *i.stepCount ();
          }

          // time
          //
          if (i.time ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "time",
                e));

            a << ::xml_schema::as_double(*i.time ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailIfAbove >
        _xsd_FailIfAbove_type_serializer_init (
          "FailIfAbove",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailIfInvalidConcentrations& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const FailIfInvalidConcentrations& i)
        {
          a << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const FailIfInvalidConcentrations& i)
        {
          l << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailIfInvalidConcentrations >
        _xsd_FailIfInvalidConcentrations_type_serializer_init (
          "FailIfInvalidConcentrations",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailOnConcentrationOscillation& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr& a, const FailOnConcentrationOscillation& i)
        {
          a << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        void
        operator<< (::xml_schema::list_stream& l,
                    const FailOnConcentrationOscillation& i)
        {
          l << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailOnConcentrationOscillation >
        _xsd_FailOnConcentrationOscillation_type_serializer_init (
          "FailOnConcentrationOscillation",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const FailISumOfConcentrationsNonConst& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // substance
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (FailISumOfConcentrationsNonConst::substance_const_iterator
                 b (i.substance ().begin ()), n (i.substance ().end ());
                 b != n; ++b)
            {
              if (typeid (FailISumOfConcentrationsNonConst::substance_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "substance",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "substance",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }

          // medium
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "medium",
                e));

            a << i.medium ();
          }

          // sum
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "sum",
                e));

            a << i.sum ();
          }

          // error
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "error",
                e));

            a << ::xml_schema::as_double(i.error ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FailISumOfConcentrationsNonConst >
        _xsd_FailISumOfConcentrationsNonConst_type_serializer_init (
          "FailISumOfConcentrationsNonConst",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const CurrentDensityGradient& i)
        {
          e << static_cast< const ::bio::xml::model::solver::StopCondition& > (i);

          // lessThan
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "lessThan",
                e));

            a << ::xml_schema::as_double(i.lessThan ());
          }

          // normalized
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "normalized",
                e));

            a << i.normalized ();
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CurrentDensityGradient >
        _xsd_CurrentDensityGradient_type_serializer_init (
          "CurrentDensityGradient",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const TimeStepAdjuster& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);
        }

        void
        operator<< (::xercesc::DOMAttr&, const TimeStepAdjuster&)
        {
        }

        void
        operator<< (::xml_schema::list_stream&,
                    const TimeStepAdjuster&)
        {
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeStepAdjuster >
        _xsd_TimeStepAdjuster_type_serializer_init (
          "TimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const SimpleTimeStepAdjuster& i)
        {
          e << static_cast< const ::bio::xml::model::solver::TimeStepAdjuster& > (i);

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << ::xml_schema::as_double(i.factor ());
          }

          // everyStepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "everyStepCount",
                e));

            a << i.everyStepCount ();
          }

          // maxStepSize
          //
          if (i.maxStepSize ())
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "maxStepSize",
                e));

            a << ::xml_schema::as_double(*i.maxStepSize ());
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SimpleTimeStepAdjuster >
        _xsd_SimpleTimeStepAdjuster_type_serializer_init (
          "SimpleTimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const AdaptiveTimeStepAdjuster& i)
        {
          e << static_cast< const ::bio::xml::model::solver::TimeStepAdjuster& > (i);

          // increase
          //
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "increase",
                "http://karolis.5grupe.lt/biosensor/model/solver",
                e));

            s << i.increase ();
          }

          // fallback
          //
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "fallback",
                "http://karolis.5grupe.lt/biosensor/model/solver",
                e));

            s << i.fallback ();
          }

          // stateStore
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            const AdaptiveTimeStepAdjuster::stateStore_type& x (i.stateStore ());
            if (typeid (AdaptiveTimeStepAdjuster::stateStore_type) == typeid (x))
            {
              ::xercesc::DOMElement& s (
                ::xsd::cxx::xml::dom::create_element (
                  "stateStore",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  e));

              s << x;
            }
            else
              tsm.serialize (
                "stateStore",
                "http://karolis.5grupe.lt/biosensor/model/solver",
                false, true, e, x);
          }

          // stopCondition
          //
          {
            ::xsd::cxx::tree::type_serializer_map< char >& tsm (
              ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

            for (AdaptiveTimeStepAdjuster::stopCondition_const_iterator
                 b (i.stopCondition ().begin ()), n (i.stopCondition ().end ());
                 b != n; ++b)
            {
              if (typeid (AdaptiveTimeStepAdjuster::stopCondition_type) == typeid (*b))
              {
                ::xercesc::DOMElement& s (
                  ::xsd::cxx::xml::dom::create_element (
                    "stopCondition",
                    "http://karolis.5grupe.lt/biosensor/model/solver",
                    e));

                s << *b;
              }
              else
                tsm.serialize (
                  "stopCondition",
                  "http://karolis.5grupe.lt/biosensor/model/solver",
                  false, true, e, *b);
            }
          }
        }

        static
        const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AdaptiveTimeStepAdjuster >
        _xsd_AdaptiveTimeStepAdjuster_type_serializer_init (
          "AdaptiveTimeStepAdjuster",
          "http://karolis.5grupe.lt/biosensor/model/solver");


        void
        operator<< (::xercesc::DOMElement& e, const increase& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << ::xml_schema::as_double(i.factor ());
          }

          // everyStepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "everyStepCount",
                e));

            a << i.everyStepCount ();
          }

          // maxStepSize
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "maxStepSize",
                e));

            a << ::xml_schema::as_double(i.maxStepSize ());
          }
        }

        void
        operator<< (::xercesc::DOMElement& e, const fallback& i)
        {
          e << static_cast< const ::xml_schema::type& > (i);

          // factor
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "factor",
                e));

            a << ::xml_schema::as_double(i.factor ());
          }

          // forStepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "forStepCount",
                e));

            a << i.forStepCount ();
          }

          // checkEveryStepCount
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "checkEveryStepCount",
                e));

            a << i.checkEveryStepCount ();
          }

          // minStepSize
          //
          {
            ::xercesc::DOMAttr& a (
              ::xsd::cxx::xml::dom::create_attribute (
                "minStepSize",
                e));

            a << ::xml_schema::as_double(i.minStepSize ());
          }
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

